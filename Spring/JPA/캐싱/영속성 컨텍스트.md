# 영속성 컨텍스트

- 영속성 컨텍스트란 엔티티를 영구 저장하는 환경임(가상의 DB)
- 엔티티 매니저를 통해 엔티티를 저장 또는 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티 보관하고 관리함

- 엔티티 매니저 생성 시 하나 만들어짐
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근, 관리 가능함

### Entity 생명주기

---

1. **비영속 상태 (Transient) :** 영속성 컨텍스트와 관계가 없는 상태

- 객체를 생성하고 값을 주어도 JPA나 Hibernate가 객체에 관해 아무것도 모르는 상태

→ DB와 매핑된 것이 아무것도 없음

```java
//갹채를 생성만 한 상태(비영속)
User user = new User();
```

1. **영속 상태 (Persistent)** : 영속성 컨텍스트에 저장된 상태

- 저장을 하고 나서 JPA가 아는 상태(관리하는 상태), save()를 했다고 해서 바로 DB에 객체에 대한 데이터가 들어가진 않음

→ JPA가 persistent 상태로 관리하고 있다가 후에 데이터 저장(1차캐시, Dirty Checking, Write Behind 등 기능 제공)

```java
//객체를 저장한 상태(영속)
em.persist(user);
```

1. **준영속 상태 (Detached)** : 영속성 컨텍스트에 저장되었다가 분리된 상태

- JPA가 더이상 관리하지 않는 상태

```java
//엔티티를 컨텍스트에서 분리한 상태(준영속)
em.detach(user);
```

1. **삭제 상태 (Removed)** : 삭제된 상태

- JPA가 관리하긴 하지만 실제 Commit이 일어날 때 삭제가 일어남

```java
//객체를 삭제한 상태(삭제)
em.remove(user);
```

**Flush?** 영속성 컨텍스트의 변경 사항을 DB에 반영하는 것

### 장점

---

- 영속성 컨텍스트에 1차 캐시 존재함(→ 캐시는 map 형태로 키값 저장)
- 동일성 보장해줌(같은 트랜잭션)
- 트랜잭션 지원하는 쓰기지연(DB에 보낼 쿼리문을 모았다가 한번에 보냄)
  - 쿼리문 모아두는 곳 : 쓰기 지연 SQL 저장소
- 변경감지(영속성 컨텍스트에 보관하는 데이터에 변경이 생겼는지 확인)

→ 변경됐다면? UPDATE 쿼리 날려줌(→ update 쿼리 수동으로 날릴 필요 없음)

- 지연로딩(연관된 객체 같이 조회 안함)
