# Fetch 전략

**Fetch?** 어플리케이션이 DB로부터 데이터를 가지고 오는 것

→ DB와 통신하여 데이터를 읽는 것에는 큰 비용 소모 해결

- FetchType.EAGER(즉시로딩)
- FetchType.LAZY(지연로딩)

### EAGER 즉시로딩

---

: 연관관계에 있는 엔티티를 전부 로딩해서 영속성 컨텍스트에 올리고 모두 가져옴

**@ManyToOne, @OneToOne**은 기본값으로 즉시로딩이 설정됨

- 연관관계가 있는 엔티티에서 무조건 다 가져와야 할 때 사용

### LAZY 지연로딩

---

: 연관관계에 있는 엔티티를 전부 가져오지 않고 호출 시 가져옴

다른 엔티티를 조회 시 해당 테이블의 프록시 객체(참조값)를 가져옴

**@OneToMany, @ManyToMany**는 기본값이 지연로딩으로 설정됨

- 연관관계가 있는 엔티티에서 자식 엔티티만 가져올 때 사용

### Fetch? Fetch join?

---

- **Fetch 전략**은 특정 엔티티를 조회 시 연관관계에 있는 다른 엔티티를 언제 불러올까에 대한 옵션
- **Fetch join**은 JPQL 만의 조회를 위한 join 방식임

---

**일반 Join**

- 쿼리에서는 join으로 조회해도, **영속성 컨텍스트에는 조회의 주체가 되는 엔티티만 조회, 영속화**
- 실제 데이터는 필요하지 않지만 **연관 엔티티가 검색조건에는 필요한 경우**에 사용

**Fetch Join**

- 조회의 주체가 되는 엔티티 이외에 Fetch Join이 걸린 연관 엔티티도 **모두 영속화**

→ 위와 같은 문제 발생 안함

- Fetch Join이 걸린 엔티티 모두 영속화 → FetchType.LAZY인 엔티티를 참조해도 이미 영속성 컨텍스트에 들어가있음 → 따로 **쿼리 실행 안 된 채** N+1 문제 해결
